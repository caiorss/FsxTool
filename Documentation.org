#+TITLE: FsxTool Documentation
#+DESCRIPTION: FsxTool library documentation and examples.
#+STARTUP: 

* Documentation
** Overview 

Package Namespaces 

 - FsxtTool.Core
   - F# extension module

 - FsxTool.Dtime
   - Date and Time manipulation combinators.

 - FsxTool.HttpReq
   - Http Request combinators

** FsxTool.Core - Extension modules for Option, String ... 
*** String
**** join

Join strings by a common prefix;

#+BEGIN_SRC fsharp
- String.join ;;
val it : (string -> seq<string> -> string)
>
- String.join "-" ["hello"; "world"; "fsharp"; "rocks"] ;;
val it : string = "hello-world-fsharp-rocks"
>
- ["hello"; "world"; "fsharp"; "rocks"] |> String.join "-" ;;
val it : string = "hello-world-fsharp-rocks"
>
#+END_SRC

**** splitByLines

Split string by lines

#+BEGIN_SRC fsharp
- String.splitLines ;;
val it : (string -> string [])
>
- String.splitLines "hello\nworld\nfsharp haskell\nunix" ;;
val it : string [] = [|"hello"; "world"; "fsharp haskell"; "unix"|]
>
#+END_SRC

**** addPrefix

Add prefix to string

#+BEGIN_SRC fsharp
- String.addPrefix ;;
val it : (string -> string -> string)
>
- String.addPrefix "prefix" "-hello" ;;
val it : string = "prefix-hello"
>
- ["hello"; "world"; "fsharp"; "csharp"] |> List.map (String.addPrefix "pref-") - ;;
val it : string list =
  ["pref-hello"; "pref-world"; "pref-fsharp"; "pref-csharp"]
>

#+END_SRC

**** addSuffix

Add suffix to string.

#+BEGIN_SRC fsharp
- String.addSuffix "-suf" "a string" ;;
val it : string = "a string-suf"
>
- ["hello"; "world"; "fsharp"; "csharp"] |> List.map (String.addSuffix "-suf") ;- ;
val it : string list = ["hello-suf"; "world-suf"; "fsharp-suf"; "csharp-suf"]
>

#+END_SRC
*** Option 
**** Overview 

Option module extension. Provides additional Option combinators.
**** map2
**** value 

- =value defaultVal t=

Example: 

#+BEGIN_SRC fsharp
- Option.value ;;
val it : ('a -> 'a option -> 'a)
> 
- Option.value 10 (Some 100) ;;
val it : int = 100
> Option.value 10 None ;;      
val it : int = 10
> 
#+END_SRC

**** TODO both 

#+BEGIN_SRC fsharp 
- Option.both ;;
val it : ('a option -> 'b option -> ('a * 'b) option)


#+END_SRC

**** TODO filter 
**** forp 

 - =Option.forp: consumer handler ma=
   - consumer: 'a -> unit
     - Function to be invoked if option value is not None.
   - handler : unit -> unit
     - Function to be invoked if option value ma is None.
   - ma      : 'a option
     - Option value.

#+BEGIN_SRC fsharp
- Option.forp ;;          
val it : (('a -> unit) -> (unit -> unit) -> 'a option -> unit) =

- Option.forp (printfn "Value is equal to %A") (fun () -> printfn "Failed") (Some 100) ;;
Value is equal to 100
val it : unit = ()
> 
- Option.forp (printfn "Value is equal to %A") (fun () -> printfn "Failed") None ;;      
Failed
val it : unit = ()
> 

#+END_SRC
** FsxTool.Dtime - Date-Time manipulation
*** Overview 

Time manipulation library.

*** Module Date 

| Function       | Singature                               | Description                                           |
|----------------+-----------------------------------------+-------------------------------------------------------|
| *Type*         |                                         |                                                       |
| T              | System.DateTime                         |                                                       |
|                |                                         |                                                       |
| *Constructors* |                                         |                                                       |
| today          | unit -> T                               | Get current date in local time.                       |
| date           | y:int -> m:int -> d:int -> T            | Create new datetime object.                           |
| datet          | y:int * m:int * d:int -> T              | Create new datettime object from tuple.               |
| curDay         | unit -> int                             | Get current day.                                      |
| curMonth       | unit -> init                            | Get current month.                                    |
| curYear        | unit -> int                             | Get current year.                                     |
|                |                                         |                                                       |
| *Extractors*   |                                         |                                                       |
| toTuple        | d:T -> int * int * int                  | Returns tuple with year, month and day.               |
| day            | d:T -> int                              | Get date day                                          |
| month          | d:T -> int                              | Get date month                                        |
| year           | d:T -> int                              | Get date yar.                                         |
| dayOfWeek      | d:T -> System.DayOfWeek                 | Get day of week                                       |
|                |                                         |                                                       |
| *Operators*    |                                         |                                                       |
| addDays        | ndays:float -> d:T -> T                 | Add n days to date.                                   |
| nextDay        | dt:T -> T                               | Increment date by one day.                            |
| prevDay        | dt:T -> T                               | Decrement date by one day.                            |
| diff           | d1:T -> d2:T -> T                       | Get the difference between date d1 and d2 (d1 - d2)   |
|                |                                         |                                                       |
| *Predicates*   |                                         |                                                       |
| isWeekend      | d:T -> bool                             | Test if date is Saturday or Sunday.                   |
| isWeekDay      | d:T -> bool                             | Test if ate is not Saturday or Sunday.                |
| isMonday       | d:T -> bool                             |                                                       |
| isTuesday      | d:T -> bool                             |                                                       |
| isWednesday    | d:T -> bool                             |                                                       |
| isThursday     | d:T -> bool                             |                                                       |
| isFriday       | d:T -> bool                             |                                                       |
| isSaturday     | d:T -> bool                             |                                                       |
| isSunday       | d:T -> bool                             |                                                       |
|                |                                         |                                                       |
| *Read / Write* |                                         |                                                       |
| toString       | T -> string                             | Get date as string with format yyyy-mm-dd (ISO 8601). |
| read           | str:string -> T option                  | Read date with format yyyy-mm-dd (ISO 8601)           |
| read2          | str:string -> T                         | Like read, but not safe.                              |
| parse          | format:string -> str:string -> T option | Try parse date. Return None if it fails.              |
| parrse2        | format:string -> str:string -> T        | Try parse data. Throws exception if it fails.         |
|                |                                         |                                                       |

Singaures: 

#+BEGIN_SRC fsharp
module Date = begin
  type T = System.DateTime
  val date : y:int -> m:int -> d:int -> System.DateTime
  val datet : y:int * m:int * d:int -> System.DateTime
  val dateFixDay : y:int -> d:int -> m:int -> System.DateTime
  val lengthOfMonth : y:int -> m:int -> int
  val toTuple : d:System.DateTime -> int * int * int
  val day : d:System.DateTime -> int
  val month : d:System.DateTime -> int
  val year : d:System.DateTime -> int
  val parse2 : format:string -> str:string -> System.DateTime
  val parse : format:string -> str:string -> System.DateTime option
  val read : str:string -> System.DateTime option
  val read2 : str:string -> System.DateTime
  val dayOfWeek : d:System.DateTime -> System.DayOfWeek
  val addDays : ndays:float -> d:System.DateTime -> System.DateTime
  val diff : d1:System.DateTime -> d2:System.DateTime -> int
  val curYear : unit -> int
  val curMonth : unit -> int
  val curDay : unit -> int
  val today : unit -> System.DateTime
  val nextDay : dt:T -> System.DateTime
  val prevDay : dt:T -> System.DateTime
  val nextDate : d:System.DateTime -> System.DateTime
  val prevDate : d:System.DateTime -> System.DateTime
  val isWeekend : d:System.DateTime -> bool
  val isWeekDay : d:System.DateTime -> bool
  val isMonday : d:T -> bool
  val isTuesday : d:T -> bool
  val isWednesday : d:T -> bool
  val isThursday : d:T -> bool
  val isFriday : d:T -> bool
  val isSaturday : d:T -> bool
  val isSunday : d:T -> bool
  val toIso8601Date : d:System.DateTime -> string
  val dateFind :
    date:System.DateTime ->
      pred:(System.DateTime -> bool) ->
        iterator:(System.DateTime -> System.DateTime) -> System.DateTime
  val unixZeroDate : System.DateTime = 1/1/1970 3:00:00 AM
  val toUnixTimestamp : dt:T -> float
  val fromUnixTimestamp : tstamp:float -> System.DateTime
end
module Instant = begin
  val now : unit -> System.DateTime
end

#+END_SRC



*** Examples 

*Load library* 

#+BEGIN_SRC fsharp
- #r "bin/FsxTool.dll" ;;

--> Referenced '/home/archbox/Documents/projects/FsxTools.fsharp/bin/FsxTool.dll' (file may be locked by F# Interactive process)

/// Module alias 
- module Date = FsxTool.Dtime.Date ;;
> 

#+END_SRC

*Create Date* 

#+BEGIN_SRC fsharp

- Date.today ;;
val it : (unit -> System.DateTime) 
> 
- Date.today() ;;
val it : System.DateTime =
  4/25/2017 12:00:00 AM {Date = 4/25/2017 12:00:00 AM;
                         Day = 25;
                         DayOfWeek = Tuesday;
                         DayOfYear = 115;
                         Hour = 0;
                         Kind = Local;
                         Millisecond = 0;
                         Minute = 0;
                         Month = 4;
                         Second = 0;
                         Ticks = 636286752000000000L;
                         TimeOfDay = 00:00:00;
                         Year = 2017;}
> 

- Date.date ;; 
val it : (int -> int -> int -> System.DateTime)
> 


- Date.date 2010 10 20 ;;
val it : System.DateTime =
  10/20/2010 12:00:00 AM {Date = 10/20/2010 12:00:00 AM;
                          Day = 20;
                          DayOfWeek = Wednesday;
                          DayOfYear = 293;
                          Hour = 0;
                          Kind = Unspecified;
                          Millisecond = 0;
                          Minute = 0;
                          Month = 10;
                          Second = 0;
                          Ticks = 634231296000000000L;
                          TimeOfDay = 00:00:00;
                          Year = 2010;}
> 

- Date.datet ;;
val it : (int * int * int -> System.DateTime) 

- Date.datet (2010, 10, 15) ;;
val it : System.DateTime =
  10/15/2010 12:00:00 AM {Date = 10/15/2010 12:00:00 AM;
                          Day = 15;
                          DayOfWeek = Friday;
                          DayOfYear = 288;
                          Hour = 0;
                          Kind = Unspecified;
                          Millisecond = 0;
                          Minute = 0;
                          Month = 10;
                          Second = 0;
                          Ticks = 634226976000000000L;
                          TimeOfDay = 00:00:00;
                          Year = 2010;}
> 



#+END_SRC

*Extract Date attributes* 

#+BEGIN_SRC fsharp 
- let d = Date.datet (2010, 10, 15) ;;   

val d : System.DateTime = 10/15/2010 12:00:00 AM

> Date.toTuple d ;;
val it : int * int * int = (2010, 10, 15)
> 

> 
> Date.day d ;;
val it : int = 15
> 
- Date.month d ;;
val it : int = 10
> 
- Date.year d ;;
val it : int = 2010
> 
- 
- Date.dayOfWeek d ;;
val it : System.DayOfWeek = Friday {value__ = 5;}
> 
- 

#+END_SRC

*Date reading / formating (ISO 8601)*

#+BEGIN_SRC fsharp
- let m =  "2010-01-21" ;;

> m |> Date.read  ;;
val it : System.DateTime option =
  Some 1/21/2010 12:01:00 AM {Date = 1/21/2010 12:00:00 AM;
                              Day = 21;
                              DayOfWeek = Thursday;
                              DayOfYear = 21;
                              Hour = 0;
                              Kind = Unspecified;
                              Millisecond = 0;
                              Minute = 1;
                              Month = 1;
                              Second = 0;
                              Ticks = 633996288600000000L;
                              TimeOfDay = 00:01:00;
                              Year = 2010;}

- m |> Date.read2 ;;        
val it : System.DateTime =
  1/21/2010 12:01:00 AM {Date = 1/21/2010 12:00:00 AM;
                         Day = 21;
                         DayOfWeek = Thursday;
                         DayOfYear = 21;
                         Hour = 0;
                         Kind = Unspecified;
                         Millisecond = 0;
                         Minute = 1;
                         Month = 1;
                         Second = 0;
                         Ticks = 633996288600000000L;
                         TimeOfDay = 00:01:00;
                         Year = 2010;}
> 
- 

- m |> Date.read2 |> Date.toString ;;
val it : string = "2010-01-21"
> 
- m |> Date.read2 |> Date.toString = m ;;
val it : bool = true
> 
#+END_SRC

*Date Parsing*

#+BEGIN_SRC fsharp 
- Date.parse2 ;;
val it : (string -> string -> System.DateTime) 


-  let parseYMD = Date.parse2 "yyyy-mm-dd" ;;

val parseYMD : (string -> System.DateTime)

> let d =  parseYMD "2010-10-21"  ;;

val d : System.DateTime = 1/21/2010 12:10:00 AM

> d ;;
val it : System.DateTime =
  1/21/2010 12:10:00 AM {Date = 1/21/2010 12:00:00 AM;
                         Day = 21;
                         DayOfWeek = Thursday;
                         DayOfYear = 21;
                         Hour = 0;
                         Kind = Unspecified;
                         Millisecond = 0;
                         Minute = 10;
                         Month = 1;
                         Second = 0;
                         Ticks = 633996294000000000L;
                         TimeOfDay = 00:10:00;
                         Year = 2010;}
> 


- d |> Date.toString ;;
val it : string = "2010-01-21"
> 
- Date.today () |> Date.toString ;;
val it : string = "2017-04-25"
> 


> 
- let dlist = [ "2009-01-20" ; "2010-08-20" ; "2011-09-15" ] ;;

val dlist : string list = ["2009-01-20"; "2010-08-20"; "2011-09-15"]

> List.map parseYMD dlist ;;                                   
val it : System.DateTime list =
  [1/20/2009 12:01:00 AM {Date = 1/20/2009 12:00:00 AM;
                          Day = 20;
                          DayOfWeek = Tuesday;
                          DayOfYear = 20;
                          Hour = 0;
                          Kind = Unspecified;
                          Millisecond = 0;
                          Minute = 1;
                          Month = 1;
                          Second = 0;
                          Ticks = 633680064600000000L;
                          TimeOfDay = 00:01:00;
                          Year = 2009;};
   1/20/2010 12:08:00 AM {Date = 1/20/2010 12:00:00 AM;
                          Day = 20;
                          DayOfWeek = Wednesday;
                          DayOfYear = 20;
                          Hour = 0;
                          Kind = Unspecified;
                          Millisecond = 0;
                          Minute = 8;
                          Month = 1;
                          Second = 0;
                          Ticks = 633995428800000000L;
                          TimeOfDay = 00:08:00;
                          Year = 2010;};
   1/15/2011 12:09:00 AM {Date = 1/15/2011 12:00:00 AM;
                          Day = 15;
                          DayOfWeek = Saturday;
                          DayOfYear = 15;
                          Hour = 0;
                          Kind = Unspecified;
                          Millisecond = 0;
                          Minute = 9;
                          Month = 1;
                          Second = 0;
                          Ticks = 634306469400000000L;
                          TimeOfDay = 00:09:00;
                          Year = 2011;}]
> 


> let parseDMY = Date.parse2 "dd/mm/yyyy"  ;;

val parseDMY : (string -> System.DateTime)

> parseDMY "10/01/2010" ;;
val it : System.DateTime =
  1/10/2010 12:01:00 AM {Date = 1/10/2010 12:00:00 AM;
                         Day = 10;
                         DayOfWeek = Sunday;
                         DayOfYear = 10;
                         Hour = 0;
                         Kind = Unspecified;
                         Millisecond = 0;
                         Minute = 1;
                         Month = 1;
                         Second = 0;
                         Ticks = 633986784600000000L;
                         TimeOfDay = 00:01:00;
                         Year = 2010;}
> 

#+END_SRC

*Date Operations*

#+BEGIN_SRC fsharp 
> let dt = Date.read2 "2010-10-15" ;;

val dt : System.DateTime = 1/15/2010 12:10:00 AM

- dt |> Date.addDays 20.0 |> Date.toString ;;
val it : string = "2010-02-04"
> 
- dt |> Date.addDays -200.0 |> Date.toString ;;
val it : string = "2009-06-29"
> 

- dt |> Date.nextDay |> Date.toString ;;       
val it : string = "2010-01-16"
> 

- dt |> Date.prevDay |> Date.toString ;;
val it : string = "2010-01-14"
> 
- Date.diff (Date.read2 "2010-10-15") (Date.read2 "2010-02-04") ;;
val it : int = 11
> 

#+END_SRC
** FsxTool.Sys 

Module: Path - Path manipulation 

| Function     | Signature                                       | Description             |
|--------------+-------------------------------------------------+-------------------------|
|              |                                                 |                         |
| join         | string list -> string                           | Join a list of paths    |
| combine      | string -> string -> string                      | Combine two paths       |
| getDirectory | string -> string                                | Get directory from path |
| getFileName  | string -> string                                | Get file name form path |
| changeExt    | (extension: string) -> (path: string) -> string | Change path extension   |
|              |                                                 |                         |

Module: File

| Function     | Signature                                       | Description               |
|--------------+-------------------------------------------------+---------------------------|
|              |                                                 |                           |
| delete       | string -> unit                                  | Delete file               |
| exists       | string -> bool                                  | Check if file exists.     |
| move         | (srcFile: string) -> (destFile: string) -> unit | Move file                 |
| copy         | (srcFile: string) -> (destFile: string) -> unit | Copy file                 |
| moveTo       | (directory: string) -> (file: string) -> unit   | Move file to directory    |
| copyTo       | (directory: string) -> (file: string) -> unit   | Copy file to directory    |
|              |                                                 |                           |
| readFile     | (file: string) -> string                        | Read all file text        |
| readAllLines | (file: string) -> string []                     | Read all file lines       |
| readAllBytes | (file: string) -> bytes []                      | Read all bytes from file. |
| writeFile    | (file: string) -> (contents: string) -> unit    | Write contents to file    |
|              |                                                 |                           |

Module: Directory 

| Function    | Signature                                | Description                            |
|-------------+------------------------------------------+----------------------------------------|
|             |                                          |                                        |
| getFiles    | path:string -> seq<string>               | Get directory files                    |
| getFilesAbs | path:string -> seq<string>               | Get directory files with absolute path |
| getFilesExt | path:string -> ext:string -> seq<string> | Get all files with given extension     |
|             |                                          |                                        |
** TODO FsxTool.HttpReq - Http Client Library 
*** Types 

Module: FsxTool.HttpReq.HttpTypes

#+BEGIN_SRC fsharp 
module HttpTypes =
    
    type HttpMethod =
        | GET 
        | POST
        | PUT
        | HEAD
        | DELETE
        | PATCH 

    type HttpProp =
        | Method            of HttpMethod 
        | ContentType       of string
        | UserAgent         of string
        | Headers           of (string * string) list 
        | PostParams        of (string * string) list
        | PostPayload       of string
        | PostPayloadBytes  of byte []
        | Timeout           of int
        | KeepAlive         of bool
        | Redirect          of bool 
#+END_SRC
*** Examples 
**** GET Request 

#+BEGIN_SRC fsharp
open FsxTool.HttpReq 
open FsxTool.HttpReq.HttpTypes 

let url = "http://www.httpbin.org/get"

let request = Http.request url [ Method GET 
                              ; ContentType "text"
                              ; UserAgent "F# Browser"
                              ; Headers [  "SoapMethod", "getOrdersXML"
                                         ; "Language",   "Spanish"
                                         ;   
                                        ]  
                                ]

val request : System.Net.HttpWebRequest

> request ;;
val it : System.Net.HttpWebRequest =
  System.Net.HttpWebRequest
    {Accept = null;
     Address = http://www.httpbin.org/get;
     AllowAutoRedirect = true;
     AllowReadStreamBuffering = false;
     AllowWriteStreamBuffering = true;
     AuthenticationLevel = MutualAuthRequested;
     AutomaticDecompression = None;
     CachePolicy = null;
     ClientCertificates = seq [];
             ... ... ... 

     ServicePoint = System.Net.ServicePoint;
     SupportsCookieContainer = true;
     Timeout = 100000;
     TransferEncoding = null;
     UnsafeAuthenticatedConnectionSharing = false;
     UseDefaultCredentials = false;
     UserAgent = "F# Browser";}


- let resp = Http.getResponse request ;;

val resp : System.Net.HttpWebResponse

> resp ;;
val it : System.Net.HttpWebResponse =
  System.Net.HttpWebResponse
    {CharacterSet = "ISO-8859-1";
     ContentEncoding = "";
     ContentLength = 291L;
     ContentType = "application/json";
     Cookies = seq [];
     Headers = seq ["Connection"; "Server"; "Date"; "Content-Type"; ...];
     IsFromCache = false;
     IsMutuallyAuthenticated = ?;
     LastModified = 4/24/2017 8:16:19 PM;
     Method = "GET";
     ProtocolVersion = 1.1;
     ResponseUri = http://www.httpbin.org/get;
     Server = "gunicorn/19.7.1";
     StatusCode = OK;
     StatusDescription = "OK";
     SupportsHeaders = true;}


- let text = Http.getResponseString request ;;

val text : string =
  "{
  "args": {}, 
  "headers": {
    "Connection": "close", 
 "+[230 chars]

> 

> printfn "%s" text ;;
{
  "args": {}, 
  "headers": {
    "Connection": "close", 
    "Content-Type": "text", 
    "Host": "www.httpbin.org", 
    "Language": "Spanish", 
    "Soapmethod": "getOrdersXML", 
    "User-Agent": "F# Browser"
  }, 
  "origin": "177.207.118.2", 
  "url": "http://www.httpbin.org/get"
}

val it : unit = ()
> 

///      Or          //
//-------------------//



let getRequest () =
    let url =  "http://www.httpbin.org/get"
    let reqParams =
        [ Method GET 
        ; ContentType "text"
        ; UserAgent "F# Browser"
        ; Headers [  "SoapMethod", "getOrdersXML"
                   ; "Language",   "Spanish"
                  ]  
          ]
    Http.requestString url reqParams

> let out = getRequest() ;;

val out : string =
  "{
  "args": {}, 
  "headers": {
    "Connection": "close", 
 "+[230 chars]

> printfn "%s" out ;;                              
{
  "args": {}, 
  "headers": {
    "Connection": "close", 
    "Content-Type": "text", 
    "Host": "www.httpbin.org", 
    "Language": "Spanish", 
    "Soapmethod": "getOrdersXML", 
    "User-Agent": "F# Browser"
  }, 
  "origin": "177.207.118.2", 
  "url": "http://www.httpbin.org/get"
}

val it : unit = ()
> 

#+END_SRC

**** POST Request 
***** Form 

#+BEGIN_SRC fsharp 
#r "bin/FsxTool.dll"

open FsxTool.HttpReq 
open FsxTool.HttpReq.HttpTypes 
 

let postForm () =
    let url = "http://www.httpbin.org/post"
    let reqParams = [
                      Method POST
                    ; ContentType "application/x-www-form-urlencoded"
                    ; UserAgent "Firefox"
                    ; PostParams [("key1", "value1");
                                  ("key2", "value2");
                                  ("key3", "value3")
                                  ]
                          ]
    printfn "%s" <| Http.requestString url reqParams
                          

> postForm () ;;
{
  "args": {}, 
  "data": "", 
  "files": {}, 
  "form": {
    "key1": "value1", 
    "key2": "value2", 
    "key3": "value3"
  }, 
  "headers": {
    "Connection": "close", 
    "Content-Length": "36", 
    "Content-Type": "application/x-www-form-urlencoded", 
    "Expect": "100-continue", 
    "Host": "www.httpbin.org", 
    "User-Agent": "Firefox"
  }, 
  "json": null, 
  "origin": "177.207.118.2", 
  "url": "http://www.httpbin.org/post"
}

val it : unit = ()
> 

#+END_SRC

***** Json payload 

#+BEGIN_SRC fsharp 
#r "bin/FsxTool.dll"

open FsxTool.HttpReq 
open FsxTool.HttpReq.HttpTypes 
 
let  httpPostJson () =    
    let url = "http://www.httpbin.org/post"
    let reqParams =  [
        Method POST;
        // Headers     [("Accept", "application/json")];
        ContentType "application/json";
        UserAgent   "Firefox Fake User Agent";
        PostPayload "{\"name\": \"John\", \"id\": 2010, \"lang\" : \"es\" }" ;
        ]
    printfn "%s" <| Http.requestString url reqParams


> httpPostJson () ;;
{
  "args": {}, 
  "data": "{\"name\": \"John\", \"id\": 2010, \"lang\" : \"es\" }", 
  "files": {}, 
  "form": {}, 
  "headers": {
    "Connection": "close", 
    "Content-Length": "44", 
    "Content-Type": "application/json", 
    "Expect": "100-continue", 
    "Host": "www.httpbin.org", 
    "User-Agent": "Firefox Fake User Agent"
  }, 
  "json": {
    "id": 2010, 
    "lang": "es", 
    "name": "John"
  }, 
  "origin": "177.207.118.2", 
  "url": "http://www.httpbin.org/post"
}

val it : unit = ()
> 

#+END_SRC

** FsxTool.Xml - Xml Parsing Combinators 
*** Functions 

Module Doc:

| Function | Signature    | Description                             |
|----------+--------------+-----------------------------------------|
| Type T   | XmlDocument  |                                         |
|          |              |                                         |
| load     | string -> T  | Get Xml document from string.           |
| loadUri  | string -> T  | Get Xml document from URI, file or URL. |
|          |              |                                         |
| root     | T -> XmlNode | Get Xml root element from XmlDocument.  |
| toString | T -> string  | Print XmlDocument to string.            |
| show     | T -> unit    | Print Xml to console.                   |
|          |              |                                         |
|          |              |                                         |

Module Node: 

| Function              | Signature                                     | Description                                             |
|-----------------------+-----------------------------------------------+---------------------------------------------------------|
| Type T                | XmlNode                                       |                                                         |
|                       |                                               |                                                         |
|                       |                                               |                                                         |
| value                 | T -> string                                   | Get node value                                          |
| name                  | T -> string                                   | Get node tag name                                       |
| innerText             | T -> string                                   | Get node innerText                                      |
|                       |                                               |                                                         |
| attrv                 | (attr: string) -> (node: T) -> string option  | Get node attribute value.                               |
| attrv2                | (attr: string) -> (node: T) -> string         | Like attrv, but not safe.                               |
|                       |                                               |                                                         |
| attributes            | T ->  seq<string * string>                    | Return all node attributes.                             |
| attrNames             | T ->  seq<string>                             | Get all node attributes                                 |
|                       |                                               |                                                         |
| childNodes            | T -> seq<T>                                   | Get child nodes.                                        |
| childNodesNoComment   | T -> seq<T>                                   | Get all child nodes ignoring comment nodes              |
| getNodesByTagName     | (tagName: string) -> (node: T) -> seq<T>      | Get all nodes with a given tag name.                    |
| getInnerTextByTagName | (tagName: string) -> (node: T) -> seq<string> | Get all text form child nodes with given tag name.      |
| nth                   | (n: int) -> T -> T                            | Get nth child node                                      |
| first                 | T -> T                                        | Get first child node                                    |
|                       |                                               |                                                         |
| getNamespaces         | T -> (string * string) list                   | Get node namespaces.                                    |
|                       |                                               |                                                         |
| toString              | T -> string                                   | Get node Xml string                                     |
|                       |                                               |                                                         |
| show                  | T -> unit                                     | Print node in Xml format.                               |
| showStruct            | T -> unit                                     | Show node Xml tags heirarchy                            |
| showStructAttr        | T -> unit                                     | Show xml node structure with attributes of each node    |
| showStructNs          | T -> unit                                     | Show xml node structure with namespace URI of each node |
|                       |                                               |                                                         |
|                       |                                               |                                                         |

*** Examples 
**** Example 1 - Parse RSS File 

*RSS Documentation*

 - [[http://www.whatisrss.com/][What Is RSS? RSS Explained - www.WhatIsRSS.com]]

 - [[https://www.xul.fr/en-xml-rss.html][RSS tutorial: building and using a feed, step by step.]]

 - [[https://www.xml.com/pub/a/2002/12/18/dive-into-xml.html][What Is RSS]]

 - [[https://www.mnot.net/rss/tutorial/][RSS Tutorial]]

 - [[http://stackoverflow.com/questions/34331595/parse-rss-pubdate-to-datetime][c# - Parse RSS pubdate to DateTime - Stack Overflow]]

*Steps*

Load assembly

#+BEGIN_SRC fsharp

> #r "bin/FsxTool.dll" ;;

- module XmlNode = FsxTool.Xml.Node ;;                                     
> module XmlDoc  = FsxTool.Xml.Doc ;;
> 

#+END_SRC

Load Xml document from Uri 

#+BEGIN_SRC fsharp 
let url = "https://www.infoq.com/feed?token=WSVCFU3gCRvgXaLKxLiHKq90pV5PnH1z"  

/// Print Xml 
///
> let doc = XmlDoc.loadUri url ;;
val doc : FsxTool.Xml.Doc.T

#+END_SRC

Print Xml document 

#+BEGIN_SRC fsharp
- FsxTool.Xml.Doc.show doc ;;             
<?xml version="1.0" encoding="utf-16"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:taxo="http://purl.org/rss/1.0/modules/taxonomy/" version="2.0">
  <channel>
    <title>InfoQ</title>
    <link>http://www.infoq.com</link>
    <description>InfoQ feed</description>
    <item>
      <title>Digital Ocean Adds Monitoring and Alerting Features</title>
      <link>http://www.infoq.com/news/2017/04/digital-ocean-monitoring?utm_campaign=infoq_content&amp;utm_source=infoq&amp;utm_medium=feed&amp;utm_term=global</link>
      <description>&lt;img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/&gt;&lt;p&gt;Cloud infrastructure provider Digital Ocean recently released capabilities for monitoring servers and sending alerts. While not novel, this free feature is indicative of growing industry attention paid to server and application insight.&lt;/p&gt; &lt;i&gt;By Richard Seroter&lt;/i&gt;</description>
      <category>Cloud Computing</category>
      <category>Monitoring Tools</category>
      <category>Monitoring</category>
      <category>IaaS</category>
      <category>DevOps</category>
      <category>Development</category>
      <category>Performance</category>
      <category>Cloud</category>
      <category>application performance management</category>
      <category>Digital Ocean</category>
      <category>news</category>
      <pubDate>Mon, 24 Apr 2017 15:01:00 GMT</pubDate>
      <guid>http://www.infoq.com/news/2017/04/digital-ocean-monitoring?utm_campaign=infoq_content&amp;utm_source=infoq&amp;utm_medium=feed&amp;utm_term=global</guid>
      <dc:creator>Richard Seroter</dc:creator>
      <dc:date>2017-04-24T15:01:00Z</dc:date>
      <dc:identifier>/news/2017/04/digital-ocean-monitoring/en</dc:identifier>
    </item>
    <item>
      <title>TensorFlow Processor Unit Architecture</title>
      <link>http://www.infoq.com/news/2017/04/tpu-architecture?utm_campaign=infoq_content&amp;utm_source=infoq&amp;utm_medium=feed&amp;utm_term=global</link>
      <description>&lt;img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/&gt;&lt;p&gt;Google's hardware engineering team that designed and developed the TensorFlow Processor Unit detailed the architecture and benchmarking experiment earlier this month. This is a follow up post on the initial announcement of the TPU from this time last year.&lt;/p&gt; &lt;i&gt;By Dylan Raithel&lt;/i&gt;</description>
      <category>Programming</category>
      <category>Artificial Intelligence</category>
      <category>Machine Learning</category>
      <category>Development</category>
      <category>Architecture &amp; Design</category>
      <category>Neural Networks</category>
      <category>Data Science</category>
      <category>TensorFlow</category>
      <category>Deep Learning</category>
      <category>news</category>
      <pubDate>Mon, 24 Apr 2017 15:00:00 GMT</pubDate>
      <guid>http://www.infoq.com/news/2017/04/tpu-architecture?utm_campaign=infoq_content&amp;utm_source=infoq&amp;utm_medium=feed&amp;utm_term=global</guid>
      <dc:creator>Dylan Raithel</dc:creator>
      <dc:date>2017-04-24T15:00:00Z</dc:date>
      <dc:identifier>/news/2017/04/tpu-architecture/en</dc:identifier>
    </item>
              ...      ... ... ... ... ... ... ... 
#+END_SRC

Show Xml structure 

#+BEGIN_SRC fsharp 
>  doc |> XmlDoc.root |> XmlNode.showStruct ;;


(0.0) channel
	(1.0) title
		(2.0) #text
	(1.1) link
		(2.0) #text
	(1.2) description
		(2.0) #text
	(1.3) item
		(2.0) title
			(3.0) #text
		(2.1) link
			(3.0) #text
		(2.2) description
			(3.0) #text
		(2.3) category
			(3.0) #text
		(2.4) category
			(3.0) #text
		(2.5) category
			(3.0) #text
		(2.6) category
			(3.0) #text
		(2.7) category
			(3.0) #text
   ... ... ... ... ... .... 
#+END_SRC fsharp 

Get Xml namespaces 

#+BEGIN_SRC fsharp 
-  XmlDoc.getNamespaces doc ;;   
val it : (string * string) list =
  [("", ""); ("dc", "http://purl.org/dc/elements/1.1/")]
> 

#+END_SRC

Get nodes with given tag name  

#+BEGIN_SRC fsharp
> let items = doc |> XmlDoc.root |> XmlNode.getNodesByTagName "item" ;;

val items : seq<System.Xml.XmlNode>

> items ;;
val it : seq<System.Xml.XmlNode> =
  seq
    [seq [seq [seq []]; seq [seq []]; seq [seq []]; seq [seq []]; ...];
     seq [seq [seq []]; seq [seq []]; seq [seq []]; seq [seq []]; ...];
     seq [seq [seq []]; seq [seq []]; seq [seq []]; seq [seq []]; ...];
     seq [seq [seq []]; seq [seq []]; seq [seq []]; seq [seq []]; ...]; ...]
> 

#+END_SRC

Display single node: 

#+BEGIN_SRC fsharp
- let n = items |> Seq.item 0 ;; 

val n : System.Xml.XmlNode

> XmlNode.show n ;;     
<title>Podcast: Chris Matts on BDD, Real Options, Risk Management and the Impact of Culture for Effective Outcomes</title>
<link>http://www.infoq.com/podcasts/chris-matts-bdd-risk-management?utm_campaign=infoq_content&amp;utm_source=infoq&amp;utm_medium=feed&amp;utm_term=global</link>
<description>&lt;img src="http://www.infoq.com/resource/podcasts/chris-matts-bdd-risk-management/en/mediumimage/oliver-gould.jpg"/&gt;&lt;p&gt;In this podcast Chris Matts, “The IT Risk Manager”, one of the original thinkers behind Real Options, Feature Injection and Behaviour Driven Development,  talks about BDD, Real Options, Risk Management and the Impact of Culture for Effective Outcomes.&lt;/p&gt; &lt;i&gt;By Chris Matts&lt;/i&gt;</description>
<category>InfoQ</category>
<category>Security</category>
<category>Business</category>
<category>Culture</category>
<category>Risk Management</category>
<category>Culture &amp; Methods</category>
<category>The InfoQ Podcast</category>
<category>Engineering Culture Podcast</category>
<category>podcast</category>
<pubDate>Mon, 24 Apr 2017 20:21:00 GMT</pubDate>
<guid>http://www.infoq.com/podcasts/chris-matts-bdd-risk-management?utm_campaign=infoq_content&amp;utm_source=infoq&amp;utm_medium=feed&amp;utm_term=global</guid>
<dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Chris Matts</dc:creator>
<dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2017-04-24T20:21:00Z</dc:date>
<dc:identifier xmlns:dc="http://purl.org/dc/elements/1.1/">/podcasts/chris-matts-bdd-risk-management/en</dc:identifier>val it : unit = ()
> 

/// Safe function - returns option type 
///
- XmlNode.findNodeTag ;;
val it : (string -> FsxTool.Xml.Node.T -> System.Xml.XmlNode option) 
> 

/// Unsafe function 
///
- XmlNode.findNodeTag2 ;;                                            
val it : (string -> FsxTool.Xml.Node.T -> System.Xml.XmlNode) 

- n |> XmlNode.findNodeTag "title" |> Option.map XmlNode.innerText ;;
val it : string option =
  Some
    "Podcast: Chris Matts on BDD, Real Options, Risk Management and the Impact of Culture for Effective Outcomes"
> 
- 
- n |> XmlNode.findNodeTag2 "title" |> XmlNode.innerText ;;          
val it : string =
  "Podcast: Chris Matts on BDD, Real Options, Risk Management and the Impact of Culture for Effective Outcomes"
> 

- n |> XmlNode.findNodeTag "pubDate" |> Option.map XmlNode.innerText ;;
val it : string option = Some "Mon, 24 Apr 2017 20:21:00 GMT"
> 
- 

- n |> XmlNode.findNodeTag "link" |> Option.map XmlNode.innerText ;;   
val it : string option =
  Some
    "http://www.infoq.com/podcasts/chris-matts-bdd-risk-management?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global"
> 

- n |> XmlNode.findNodeTag "dc:date" |> Option.map XmlNode.innerText ;;
val it : string option = Some "2017-04-24T20:21:00Z"
> 

> 
- n |> XmlNode.getNodesByTagName "category" |> Seq.map XmlNode.innerText ;;
val it : seq<string> = seq ["InfoQ"; "Security"; "Business"; "Culture"; ...]
> 

- n |> XmlNode.getNodesByTagName "category" |> Seq.map XmlNode.innerText |> Seq.iter (printfn "%s") ;;
InfoQ
Security
Business
Culture
Risk Management
Culture & Methods
The InfoQ Podcast
Engineering Culture Podcast
podcast
val it : unit = ()
> 


- n |> XmlNode.getInnerTextByTagName "category" ;;
val it : seq<string> =
  seq ["Conferences"; "QCon"; "Architecture"; "Distributed Systems"; ...]
> 
- n |> XmlNode.getInnerTextByTagName "category" |> Seq.iter (printfn "%s") ;;
Conferences
QCon
Architecture
Distributed Systems
Architecture & Design
Resilience
Microservices
QCon London 2017
presentation
val it : unit = ()
> 

#+END_SRC

Get all Items from RSS 

#+BEGIN_SRC fsharp
type RSSItem = {
    RSSTitle:    string
  ; RSSDesc:     string     
  ; RSSCategory: string list
  ; RSSDate:     string
  ; RSSLink:     string 
    }


let parseNode (node: System.Xml.XmlNode) =
    let title = node |> XmlNode.getTagText2 "title" 
    let desc  = node |> XmlNode.getTagText2  "description"
    let cats  = node |> XmlNode.getInnerTextByTagName "category" |> List.ofSeq
    let date  = node |> XmlNode.getTagText2 "dc:date"
    let link  = node |> XmlNode.getTagText2 "link"
    
    { RSSTitle = title
    ; RSSDesc  = desc
    ; RSSCategory = cats
    ; RSSDate = date
    ; RSSLink = link 
    }

> parseNode n ;;
val it : RSSItem =
  {RSSTitle = "Presentation: From Microliths to Microsystems";
   RSSDesc =
    "<img src="http://www.infoq.com/resource/presentations/microservices-principles-2017/en/mediumimage/Jonbig.JPG"/><p>Jonas Boner explores microservices from first principles, distilling their essence and putting them in their true context: distributed systems. In order to make each microservice resilient and elastic in and of itself, we have to design each individual microservice as a distributed system—a «microsystem»—architected from the ground up using the reactive principles.</p> <i>By Jonas Bonér</i>";
   RSSCategory =
    ["Conferences"; "QCon"; "Architecture"; "Distributed Systems";
     "Architecture & Design"; "Resilience"; "Microservices";
     "QCon London 2017"; "presentation"];
   RSSDate = "2017-04-24T21:30:00Z";
   RSSLink =
    "http://www.infoq.com/presentations/microservices-principles-2017?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global";}
> 


> rssItem.RSSDate ;; 
val it : string = "2017-04-24T21:30:00Z"
> 
- rssItem.RSSLink ;; 
val it : string =
  "http://www.infoq.com/presentations/microservices-principles-2017?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global"
> 
- rssItem.RSSTitle ;;
val it : string = "Presentation: From Microliths to Microsystems"
> 
- 


> let rssdata = items |> Seq.map parseNode ;;

val rssdata : seq<RSSItem>

> rssdata ;;
val it : seq<RSSItem> =
  seq
    [{RSSTitle = "Presentation: From Microliths to Microsystems";
      RSSDesc =
       "<img src="http://www.infoq.com/resource/presentations/microservices-principles-2017/en/mediumimage/Jonbig.JPG"/><p>Jonas Boner explores microservices from first principles, distilling their essence and putting them in their true context: distributed systems. In order to make each microservice resilient and elastic in and of itself, we have to design each individual microservice as a distributed system—a «microsystem»—architected from the ground up using the reactive principles.</p> <i>By Jonas Bonér</i>";
      RSSCategory =
       ["Conferences"; "QCon"; "Architecture"; "Distributed Systems";
        "Architecture & Design"; "Resilience"; "Microservices";
        "QCon London 2017"; "presentation"];
      RSSDate = "2017-04-24T21:30:00Z";
      RSSLink =
       "http://www.infoq.com/presentations/microservices-principles-2017?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global";};
     {RSSTitle =
       "Podcast: Chris Matts on BDD, Real Options, Risk Management and the Impact of Culture for Effective Outcomes";
      RSSDesc =
       "<img src="http://www.infoq.com/resource/podcasts/chris-matts-bdd-risk-management/en/mediumimage/oliver-gould.jpg"/><p>In this podcast Chris Matts, “The IT Risk Manager”, one of the original thinkers behind Real Options, Feature Injection and Behaviour Driven Development,  talks about BDD, Real Options, Risk Management and the Impact of Culture for Effective Outcomes.</p> <i>By Chris Matts</i>";
      RSSCategory =
       ["InfoQ"; "Security"; "Business"; "Culture"; "Risk Management";
        "Culture & Methods"; "The InfoQ Podcast";
        "Engineering Culture Podcast"; "podcast"];
      RSSDate = "2017-04-24T20:21:00Z";
      RSSLink =
       "http://www.infoq.com/podcasts/chris-matts-bdd-risk-management?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global";};
     {RSSTitle = "Digital Ocean Adds Monitoring and Alerting Features";
      RSSDesc =
       "<img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/><p>Cloud infrastructure provider Digital Ocean recently released capabilities for monitoring servers and sending alerts. While not novel, this free feature is indicative of growing industry attention paid to server and application insight.</p> <i>By Richard Seroter</i>";
      RSSCategory =
       ["Cloud Computing"; "Monitoring Tools"; "Monitoring"; "IaaS"; "DevOps";
        "Development"; "Performance"; "Cloud";
        "application performance management"; "Digital Ocean"; "news"];
      RSSDate = "2017-04-24T15:01:00Z";
      RSSLink =
       "http://www.infoq.com/news/2017/04/digital-ocean-monitoring?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global";};
     {RSSTitle = "TensorFlow Processor Unit Architecture";
      RSSDesc =
       "<img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/><p>Google's hardware engineering team that designed and developed the TensorFlow Processor Unit detailed the architecture and benchmarking experiment earlier this month. This is a follow up post on the initial announcement of the TPU from this time last year.</p> <i>By Dylan Raithel</i>";
      RSSCategory =
       ["Programming"; "Artificial Intelligence"; "Machine Learning";
        "Development"; "Architecture & Design"; "Neural Networks";
        "Data Science"; "TensorFlow"; "Deep Learning"; "news"];
      RSSDate = "2017-04-24T15:00:00Z";
      RSSLink =
       "http://www.infoq.com/news/2017/04/tpu-architecture?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global";};
     ...]
> 

#+END_SRC

Print all items: 

#+BEGIN_SRC fsharp 

let dispRSSItem (item: RSSItem) =
    System.Console.WriteLine("
Title:         {0}
Date:          {1}
Description:   {2}   
Link:          {3}
    ", item.RSSTitle, item.RSSDate, item.RSSDesc, item.RSSLink)
    

> items |> Seq.map parseNode |> Seq.iter dispRSSItem ;;          

Title:         Presentation: From Microliths to Microsystems
Date:          2017-04-24T21:30:00Z
Description:   <img src="http://www.infoq.com/resource/presentations/microservices-principles-2017/en/mediumimage/Jonbig.JPG"/><p>Jonas Boner explores microservices from first principles, distilling their essence and putting them in their true context: distributed systems. In order to make each microservice resilient and elastic in and of itself, we have to design each individual microservice as a distributed system—a «microsystem»—architected from the ground up using the reactive principles.</p> <i>By Jonas Bonér</i>   
Link:          http://www.infoq.com/presentations/microservices-principles-2017?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global
    

Title:         Podcast: Chris Matts on BDD, Real Options, Risk Management and the Impact of Culture for Effective Outcomes
Date:          2017-04-24T20:21:00Z
Description:   <img src="http://www.infoq.com/resource/podcasts/chris-matts-bdd-risk-management/en/mediumimage/oliver-gould.jpg"/><p>In this podcast Chris Matts, “The IT Risk Manager”, one of the original thinkers behind Real Options, Feature Injection and Behaviour Driven Development,  talks about BDD, Real Options, Risk Management and the Impact of Culture for Effective Outcomes.</p> <i>By Chris Matts</i>   
Link:          http://www.infoq.com/podcasts/chris-matts-bdd-risk-management?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global
    

Title:         Digital Ocean Adds Monitoring and Alerting Features
Date:          2017-04-24T15:01:00Z
Description:   <img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/><p>Cloud infrastructure provider Digital Ocean recently released capabilities for monitoring servers and sending alerts. While not novel, this free feature is indicative of growing industry attention paid to server and application insight.</p> <i>By Richard Seroter</i>   
Link:          http://www.infoq.com/news/2017/04/digital-ocean-monitoring?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global
    

Title:         TensorFlow Processor Unit Architecture
Date:          2017-04-24T15:00:00Z
Description:   <img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/><p>Google's hardware engineering team that designed and developed the TensorFlow Processor Unit detailed the architecture and benchmarking experiment earlier this month. This is a follow up post on the initial announcement of the TPU from this time last year.</p> <i>By Dylan Raithel</i>   
Link:          http://www.infoq.com/news/2017/04/tpu-architecture?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global
    

Title:         The AI Misinformation Epidemic
Date:          2017-04-24T14:22:00Z
Description:   <img src="http://www.infoq.com/styles/i/logo_bigger.jpg"/><p>Over the past five years, Google searches for Machine Learning have gone up five times. “Fo anything that has machine learning in it or blockchain in it, the valuation goes up, 2, 3, 4, 5x”, Andy Stewart pointed out. Zachary Lipton claimed a "misinformation epidemic" in the field in a recent blog post. In this article we present the technical perspective of ML and how it can be presented.</p> <i>By Alex Giamas</i>   
Link:          http://www.infoq.com/news/2017/04/AI-Misinformation-Epidemic?utm_campaign=infoq_content&utm_source=infoq&utm_medium=feed&utm_term=global
    
   ....  ... ... ... 


#+END_SRC


*Script* 

File: xmlScript.fsx 

#+BEGIN_SRC fsharp 

#r "bin/FsxTool.dll"

module XmlDoc  =  FsxTool.Xml.Doc
module XmlNode =  FsxTool.Xml.Node

let url = "https://www.infoq.com/feed?token=WSVCFU3gCRvgXaLKxLiHKq90pV5PnH1z"

let doc = XmlDoc.loadUri url

XmlDoc.show doc

let root = XmlDoc.root doc

let items = doc |> XmlDoc.root |> XmlNode.getNodesByTagName "item" ;;

let n = items |> Seq.item 0 ;;

type RSSItem = {
    RSSTitle:    string
  ; RSSDesc:     string     
  ; RSSCategory: string list
  ; RSSDate:     string
  ; RSSLink:     string 
    }

let parseNode (node: System.Xml.XmlNode) =
    let title = node |> XmlNode.getTagText2 "title" 
    let desc  = node |> XmlNode.getTagText2  "description"
    let cats  = node |> XmlNode.getInnerTextByTagName "category" |> List.ofSeq
    let date  = node |> XmlNode.getTagText2 "dc:date"
    let link  = node |> XmlNode.getTagText2 "link"
    
    { RSSTitle = title
    ; RSSDesc  = desc
    ; RSSCategory = cats
    ; RSSDate = date
    ; RSSLink = link 
    }

let dispRSSItem (item: RSSItem) =
    System.Console.WriteLine("
Title:         {0}
Date:          {1}
Description:   {2}   
Link:          {3}
    ", item.RSSTitle, item.RSSDate, item.RSSDesc, item.RSSLink)
    

#+END_SRC


Usage: 

#+BEGIN_SRC fsharp 
$ fsharpi --use:xmlScript.fsx 

F# Interactive for F# 4.1
Freely distributed under the Apache 2.0 Open Source License

For help type #help;;

> 
--> Referenced '/home/archbox/Documents/projects/FsxTools.fsharp/bin/FsxTool.dll' (file may be locked by F# Interactive process)
  ... ... .., 

val url : string =
  "https://www.infoq.com/feed?token=WSVCFU3gCRvgXaLKxLiHKq90pV5PnH1z"
val doc : FsxTool.Xml.Doc.T
val root : System.Xml.XmlElement
val items : seq<System.Xml.XmlNode>

> 
val n : System.Xml.XmlNode

> 
type RSSItem =
  {RSSTitle: string;
   RSSDesc: string;
   RSSCategory: string list;
   RSSDate: string;
   RSSLink: string;}
val parseNode : node:System.Xml.XmlNode -> RSSItem
val dispRSSItem : item:RSSItem -> unit

> 
- XmlNode.show n ;;
<title>Presentation: From Microliths to Microsystems</title>
<link>http://www.infoq.com/presentations/microservices-principles-2017?utm_campaign=infoq_content&amp;utm_source=infoq&amp;utm_medium=feed&amp;utm_term=global</link>
<description>&lt;img src="http://www.infoq.com/resource/presentations/microservices-principles-2017/en/mediumimage/Jonbig.JPG"/&gt;&lt;p&gt;Jonas Boner explores microservices from first principles, distilling their essence and putting them in their true context: distributed systems. In order to make each microservice resilient and elastic in and of itself, we have to design each individual microservice as a distributed system—a «microsystem»—architected from the ground up using the reactive principles.&lt;/p&gt; &lt;i&gt;By Jonas Bonér&lt;/i&gt;</description>
<category>Conferences</category>
<category>QCon</category>
<category>Architecture</category>
<category>Distributed Systems</category>
<category>Architecture &amp; Design</category>
<category>Resilience</category>
<category>Microservices</category>
<category>QCon London 2017</category>
<category>presentation</category>
<pubDate>Mon, 24 Apr 2017 21:30:00 GMT</pubDate>
<guid>http://www.infoq.com/presentations/microservices-principles-2017?utm_campaign=infoq_content&amp;utm_source=infoq&amp;utm_medium=feed&amp;utm_term=global</guid>
<dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jonas Bonér</dc:creator>
<dc:date xmlns:dc="http://purl.org/dc/elements/1.1/">2017-04-24T21:30:00Z</dc:date>
<dc:identifier xmlns:dc="http://purl.org/dc/elements/1.1/">/presentations/microservices-principles-2017/en</dc:identifier>val it : unit = ()
> 


#+END_SRC
